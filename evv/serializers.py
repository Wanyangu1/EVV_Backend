# serializers.py - UPDATED
from rest_framework import serializers
from .models import Client, Employee, Visit, ClientEmployeeXref
from dateutil import parser
import datetime
import re
import logging
from django.db import transaction
from django.utils import timezone
logger = logging.getLogger(__name__)


class FlexibleDateField(serializers.DateField):
    def to_internal_value(self, value):
        formats = ['%Y-%m-%d', '%m/%d/%Y', '%m-%d-%Y', '%Y/%m/%d', '%d/%m/%Y']
        for fmt in formats:
            try:
                return datetime.datetime.strptime(value, fmt).date()
            except (ValueError, TypeError):
                continue
        return super().to_internal_value(value)

class FlexibleDateTimeField(serializers.DateTimeField):
    """
    A super flexible datetime field that accepts almost any datetime format.
    """
    
    def to_internal_value(self, value):
        if value is None:
            return None
            
        if isinstance(value, datetime.datetime):
            return value
            
        if isinstance(value, str):
            # First try to parse with dateutil (handles almost everything)
            try:
                return parser.parse(value)
            except (ValueError, TypeError):
                pass
            
            # Then try our custom formats
            formats = [
                '%Y-%m-%dT%H:%M:%S.%fZ',
                '%Y-%m-%dT%H:%M:%SZ',
                '%Y-%m-%dT%H:%M:%S',
                '%Y-%m-%d %H:%M:%S.%f',
                '%Y-%m-%d %H:%M:%S',
                '%Y-%m-%d %H:%M',
                '%Y/%m/%d %H:%M:%S',
                '%m/%d/%Y %H:%M:%S',
                '%d/%m/%Y %H:%M:%S',
                '%Y%m%dT%H%M%SZ',
                '%Y%m%d %H%M%S',
                '%Y-%m-%d',
                '%Y/%m/%d',
                '%m/%d/%Y',
            ]
            
            for fmt in formats:
                try:
                    return datetime.datetime.strptime(value, fmt)
                except (ValueError, TypeError):
                    continue
        
        # If we get here and value is not None, try the parent
        if value is not None:
            try:
                return super().to_internal_value(value)
            except:
                # Last resort: try to create from timestamp
                try:
                    if isinstance(value, (int, float)):
                        return datetime.datetime.fromtimestamp(value)
                    elif isinstance(value, str) and value.isdigit():
                        return datetime.datetime.fromtimestamp(int(value))
                except:
                    pass
        
        # If nothing works, return None (or raise validation error)
        return None
    
    def to_representation(self, value):
        # Always return ISO format for consistency
        if value:
            return value.isoformat()
        return None

class VisitSerializer(serializers.ModelSerializer):
    # Use flexible fields
    schedule_start_time = FlexibleDateTimeField(required=False)
    schedule_end_time = FlexibleDateTimeField(required=False)
    actual_start_time = FlexibleDateTimeField(required=False)
    actual_end_time = FlexibleDateTimeField(required=False)
    
    # These will be auto-generated by the model
    visit_other_id = serializers.CharField(read_only=True)
    sequence_id = serializers.CharField(required=False)
    
    # created_by is optional and can be null
    created_by = serializers.PrimaryKeyRelatedField(
        queryset=Employee.objects.all(),
        required=False,
        allow_null=True
    )
    
    class Meta:
        model = Visit
        fields = [
            'id', 'client', 'employee', 'visit_other_id', 'sequence_id',
            'visit_type', 'schedule_start_time', 'schedule_end_time',
            'actual_start_time', 'actual_end_time', 'start_latitude',
            'start_longitude', 'end_latitude', 'end_longitude',
            'location_verified', 'location_distance_miles',
            'payer_id', 'procedure_code', 'visit_time_zone',
            'client_verified_times', 'client_verified_tasks',
            'client_verified_service', 'client_signature_available',
            'client_voice_recording', 'bill_visit', 'hours_to_bill',
            'hours_to_pay', 'tasks_completed', 'tasks_refused',
            'calls', 'visit_changes', 'memo', 'contingency_plan',
            'submitted_to_evv', 'evv_submission_id', 'evv_submission_date',
            'created_at', 'updated_at', 'created_by'
        ]
        read_only_fields = [
            'id', 'created_at', 'updated_at', 'submitted_to_evv',
            'evv_submission_id', 'evv_submission_date', 'visit_other_id'
        ]
    
    def create(self, validated_data):
        # Remove visit_other_id if somehow provided
        validated_data.pop('visit_other_id', None)
        
        # Remove sequence_id if empty
        if 'sequence_id' in validated_data and not validated_data['sequence_id']:
            validated_data.pop('sequence_id')
        
        # If created_by is not provided, set to None
        if 'created_by' not in validated_data:
            validated_data['created_by'] = None
        
        return super().create(validated_data)

class ClientSerializer(serializers.ModelSerializer):
    date_of_birth = FlexibleDateField(required=False)

    class Meta:
        model = Client
        fields = '__all__'

class EmployeeSerializer(serializers.ModelSerializer):
    date_of_birth = FlexibleDateField(required=False)
    hire_date = FlexibleDateField(required=False)

    class Meta:
        model = Employee
        fields = '__all__'


class EVVXrefSerializer(serializers.Serializer):
    """Serializer for EVV-compliant Xref data"""
    
    def to_representation(self, instance):
        """Convert Xref instance to EVV format"""
        
        # Get validated client Medicaid ID
        client_medicaid = getattr(instance.client, 'medicaid_id', '')
        if not client_medicaid or not re.match(r'^A\d{8}$', client_medicaid):
            raise serializers.ValidationError(f"Invalid Medicaid ID for client {instance.client}")
        
        # Get employee SSN
        employee_ssn = getattr(instance.employee, 'ssn', '')
        if not employee_ssn or not re.match(r'^\d{9}$', employee_ssn):
            raise serializers.ValidationError(f"Invalid SSN for employee {instance.employee}")
        
        # Check procedure code is in allowed list (Section 10.10)
        allowed_codes = ['S5125', 'T2017', 'T1021', 'S5130', 'T1019', 'S5150', 'S5151']
        if instance.procedure_code not in allowed_codes:
            raise serializers.ValidationError(
                f"Procedure code {instance.procedure_code} not allowed for live-in caregiver"
            )
        
        # Build the EVV-compliant payload
        return {
            "ClientIDQualifier": "ClientMedicaidID",
            "ClientIdentifier": client_medicaid,
            "EmployeeQualifier": "EmployeeSSN",
            "EmployeeIdentifier": employee_ssn,
            "XRefStartDate": instance.start_date.isoformat() if instance.start_date else None,
            "XRefEndDate": instance.end_date.isoformat() if instance.end_date else None,
            "PayerID": instance.payer_id,
            "PayerProgram": "AHCCCS",  # REQUIRED: Must be exactly "AHCCCS"
            "ProcedureCode": instance.procedure_code,
            "Modifier1": instance.modifier1,
            "Modifier2": instance.modifier2,
            "Modifier3": instance.modifier3,
            "Modifier4": instance.modifier4,
            "LiveIn": instance.live_in,  # Must be "Yes" or "No" as string
            "Relationship": instance.relationship
        }

# serializers.py - UPDATE XrefSerializer
class XrefSerializer(serializers.ModelSerializer):
    """
    Simplified serializer for ClientEmployeeXref
    Accepts client and employee IDs directly
    """
    client_id = serializers.IntegerField(write_only=True, required=True)
    employee_id = serializers.IntegerField(write_only=True, required=True)
    start_date = FlexibleDateField(required=True)  # CHANGED TO FlexibleDateField
    end_date = FlexibleDateField(required=False, allow_null=True)  # CHANGED TO FlexibleDateField
    
    class Meta:
        model = ClientEmployeeXref
        fields = [
            'id', 'client_id', 'employee_id', 'xref_other_id', 'sequence_id',
            'start_date', 'end_date', 'payer_id', 'payer_program',
            'procedure_code', 'modifier1', 'modifier2', 'modifier3', 'modifier4',
            'live_in', 'relationship', 'submitted_to_evv', 'evv_submission_id',
            'evv_submission_date', 'created_at', 'updated_at'
        ]
        read_only_fields = [
            'id', 'xref_other_id', 'sequence_id', 'created_at', 'updated_at',
            'submitted_to_evv', 'evv_submission_id', 'evv_submission_date'
        ]
    
    def validate(self, data):
        """Validate the xref data"""
        # Check if end_date is after start_date
        if data.get('end_date') and data['end_date'] <= data['start_date']:
            raise serializers.ValidationError({
                'end_date': 'End date must be after start date'
            })
        
        # Validate procedure code is in allowed list
        allowed_codes = ['S5125', 'T2017', 'T1021', 'S5130', 'T1019', 'S5150', 'S5151']
        if data.get('procedure_code') not in allowed_codes:
            raise serializers.ValidationError({
                'procedure_code': f'Procedure code must be one of: {", ".join(allowed_codes)}'
            })
        
        # Validate relationship is in allowed list
        allowed_relationships = [
            'Spouse', 'Adult children/Stepchildren', 'Son-in-law/Daughter-in-law',
            'Grandchildren', 'Siblings/Step siblings', 'Parents/Adoptive Parents/Legal Guardians',
            'Stepparents', 'Grandparents', 'Mother-in-law/Father-in-law',
            'Brother-in-law/Sister-in-law', 'Other'
        ]
        if data.get('relationship') not in allowed_relationships:
            raise serializers.ValidationError({
                'relationship': 'Please select a valid relationship type'
            })
        
        return data
    
    def create(self, validated_data):
        """Create a new xref record"""
        try:
            with transaction.atomic():
                # Extract client_id and employee_id
                client_id = validated_data.pop('client_id')
                employee_id = validated_data.pop('employee_id')
                
                # Get client and employee objects
                client = Client.objects.get(id=client_id)
                employee = Employee.objects.get(id=employee_id)
                
                # Check if relationship already exists
                existing_xref = ClientEmployeeXref.objects.filter(
                    client=client,
                    employee=employee
                ).first()
                
                if existing_xref:
                    # Update existing relationship
                    for field, value in validated_data.items():
                        setattr(existing_xref, field, value)
                    
                    # Increment sequence ID
                    existing_xref.sequence_id += 1
                    existing_xref.save()
                    
                    logger.info(f"Updated existing xref: {existing_xref.xref_other_id}")
                    return existing_xref
                
                # Create new xref
                validated_data['client'] = client
                validated_data['employee'] = employee
                
                # Auto-generate xref_other_id
                if 'xref_other_id' not in validated_data or not validated_data.get('xref_other_id'):
                    timestamp = int(timezone.now().timestamp())
                    validated_data['xref_other_id'] = f"XREF_{client.id}_{employee.id}_{timestamp}"
                
                # Set default sequence ID
                if 'sequence_id' not in validated_data:
                    validated_data['sequence_id'] = 1
                
                # Set default values if not provided
                if 'payer_program' not in validated_data:
                    validated_data['payer_program'] = 'AHCCCS'
                
                if 'live_in' not in validated_data:
                    validated_data['live_in'] = 'No'
                
                xref = ClientEmployeeXref.objects.create(**validated_data)
                logger.info(f"Created new xref: {xref.xref_other_id}")
                
                return xref
                
        except Client.DoesNotExist:
            raise serializers.ValidationError({
                'client_id': 'Client not found'
            })
        except Employee.DoesNotExist:
            raise serializers.ValidationError({
                'employee_id': 'Employee not found'
            })
        except Exception as e:
            logger.exception(f"Error creating xref: {str(e)}")
            raise serializers.ValidationError({
                'error': f'Failed to create xref: {str(e)}'
            })
# Special serializers for EVV transformation
class EVVVisitSerializer(serializers.Serializer):
    """Serializer for transforming Visit objects to EVV format"""
    
    def to_representation(self, instance):
        """Convert Visit instance to EVV-compliant JSON"""
        
        if instance.visit_type == 'scheduled':
            return self._format_scheduled_visit(instance)
        else:  # completed
            return self._format_completed_visit(instance)
    
    def _format_scheduled_visit(self, visit):
        """Format a scheduled visit (no calls)"""
        return {
            "ProviderIdentification": {
                "ProviderQualifier": "MedicaidID",
                "ProviderID": "211108"  # Should be from settings
            },
            "VisitOtherID": visit.visit_other_id,
            "SequenceID": visit.sequence_id,
            "EmployeeQualifier": "EmployeeSSN",
            "EmployeeIdentifier": str(visit.employee.ssn),
            "ClientIDQualifier": "ClientCustomID",
            "ClientID": str(visit.client.medicaid_id),
            "ClientOtherID": str(visit.client.medicaid_id),
            "VisitCancelledIndicator": False,
            "PayerID": visit.payer_id,
            "PayerProgram": "AHCCCS",
            "ProcedureCode": visit.procedure_code,
            "Modifier1": None,
            "Modifier2": None,
            "Modifier3": None,
            "Modifier4": None,
            "VisitTimeZone": visit.visit_time_zone,
            "ScheduleStartTime": visit.schedule_start_time.strftime("%Y-%m-%dT%H:%M:%SZ") if visit.schedule_start_time else None,
            "ScheduleEndTime": visit.schedule_end_time.strftime("%Y-%m-%dT%H:%M:%SZ") if visit.schedule_end_time else None,
            "AdjInDateTime": None,
            "AdjOutDateTime": None,
            "BillVisit": visit.bill_visit,
            "HoursToBill": 0,
            "HoursToPay": 0,
            "Memo": visit.memo or f"Scheduled visit for {visit.client.first_name}",
            "ClientVerifiedTimes": False,
            "ClientVerifiedTasks": False,
            "ClientVerifiedService": False,
            "ClientSignatureAvailable": False,
            "ClientVoiceRecording": False,
            "ContingencyPlan": visit.contingency_plan or None,
            "Reschedule": False,
            "Calls": [],  # No calls for schedules
            "VisitChanges": [],
            "VisitTasks": []
        }
    
    def _format_completed_visit(self, visit):
        """Format a completed visit (with calls)"""
        
        # Format calls
        formatted_calls = []
        for call in visit.calls:
            formatted_calls.append({
                "CallExternalID": call.get('call_external_id', f"CALL{int(datetime.datetime.now().timestamp())}"),
                "CallDateTime": call.get('call_date_time'),
                "CallAssignment": call.get('call_assignment'),
                "GroupCode": None,
                "CallType": call.get('call_type', 'Mobile'),
                "ProcedureCode": call.get('procedure_code', visit.procedure_code),
                "ClientIdentifierOnCall": call.get('client_identifier_on_call', str(visit.client.medicaid_id)),
                "MobileLogin": call.get('mobile_login', ''),
                "CallLatitude": call.get('call_latitude'),
                "CallLongitude": call.get('call_longitude'),
                "Location": call.get('location', ''),
                "VisitLocationType": call.get('visit_location_type', '1'),
                "TelephonyPIN": None,
                "OriginatingPhoneNumber": None,
                "IpAddress": None,
                "WorkerPin": None
            })
        
        # Format tasks
        formatted_tasks = []
        for task_id in visit.tasks_completed:
            formatted_tasks.append({
                "TaskID": task_id,
                "TaskRefused": False
            })
        
        for task_id in visit.tasks_refused:
            formatted_tasks.append({
                "TaskID": task_id,
                "TaskRefused": True
            })
        
        # Format visit changes
        formatted_changes = []
        for change in visit.visit_changes:
            formatted_changes.append({
                "SequenceID": change.get('sequence_id'),
                "ChangeMadeBy": change.get('change_made_by'),
                "ChangeDateTime": change.get('change_date_time'),
                "GroupCode": None,
                "ReasonCode": change.get('reason_code'),
                "ChangeReasonMemo": change.get('change_reason_memo', ''),
                "ResolutionCode": None
            })
        
        return {
            "ProviderIdentification": {
                "ProviderQualifier": "MedicaidID",
                "ProviderID": "211108"  # Should be from settings
            },
            "VisitOtherID": visit.visit_other_id,
            "SequenceID": visit.sequence_id,
            "EmployeeQualifier": "EmployeeSSN",
            "EmployeeIdentifier": str(visit.employee.ssn),
            "ClientIDQualifier": "ClientCustomID",
            "ClientID": str(visit.client.medicaid_id),
            "ClientOtherID": str(visit.client.medicaid_id),
            "VisitCancelledIndicator": False,
            "PayerID": visit.payer_id,
            "PayerProgram": "AHCCCS",
            "ProcedureCode": visit.procedure_code,
            "Modifier1": None,
            "Modifier2": None,
            "Modifier3": None,
            "Modifier4": None,
            "VisitTimeZone": visit.visit_time_zone,
            "ScheduleStartTime": visit.schedule_start_time.strftime("%Y-%m-%dT%H:%M:%SZ") if visit.schedule_start_time else None,
            "ScheduleEndTime": visit.schedule_end_time.strftime("%Y-%m-%dT%H:%M:%SZ") if visit.schedule_end_time else None,
            "AdjInDateTime": visit.actual_start_time.strftime("%Y-%m-%dT%H:%M:%SZ") if visit.actual_start_time else None,
            "AdjOutDateTime": visit.actual_end_time.strftime("%Y-%m-%dT%H:%M:%SZ") if visit.actual_end_time else None,
            "BillVisit": visit.bill_visit,
            "HoursToBill": float(visit.hours_to_bill),
            "HoursToPay": float(visit.hours_to_pay),
            "Memo": visit.memo or f"Completed visit for {visit.client.first_name}",
            "ClientVerifiedTimes": visit.client_verified_times,
            "ClientVerifiedTasks": visit.client_verified_tasks,
            "ClientVerifiedService": visit.client_verified_service,
            "ClientSignatureAvailable": visit.client_signature_available,
            "ClientVoiceRecording": visit.client_voice_recording,
            "ContingencyPlan": visit.contingency_plan or None,
            "Reschedule": False,
            "Calls": formatted_calls,
            "VisitChanges": formatted_changes,
            "VisitTasks": formatted_tasks
        }