# serializers.py - UPDATED
from rest_framework import serializers
from .models import Client, Employee, Visit, ClientEmployeeXref
from dateutil import parser
import datetime
import re
import logging
from django.db import transaction
from django.utils import timezone
from django.contrib.auth import get_user_model

logger = logging.getLogger(__name__)

User = get_user_model()


class FlexibleDateField(serializers.DateField):
    def to_internal_value(self, value):
        formats = ['%Y-%m-%d', '%m/%d/%Y', '%m-%d-%Y', '%Y/%m/%d', '%d/%m/%Y']
        for fmt in formats:
            try:
                return datetime.datetime.strptime(value, fmt).date()
            except (ValueError, TypeError):
                continue
        return super().to_internal_value(value)

class FlexibleDateTimeField(serializers.DateTimeField):
    """
    A super flexible datetime field that accepts almost any datetime format.
    """
    
    def to_internal_value(self, value):
        if value is None:
            return None
            
        if isinstance(value, datetime.datetime):
            return value
            
        if isinstance(value, str):
            # First try to parse with dateutil (handles almost everything)
            try:
                return parser.parse(value)
            except (ValueError, TypeError):
                pass
            
            # Then try our custom formats
            formats = [
                '%Y-%m-%dT%H:%M:%S.%fZ',
                '%Y-%m-%dT%H:%M:%SZ',
                '%Y-%m-%dT%H:%M:%S',
                '%Y-%m-%d %H:%M:%S.%f',
                '%Y-%m-%d %H:%M:%S',
                '%Y-%m-%d %H:%M',
                '%Y/%m/%d %H:%M:%S',
                '%m/%d/%Y %H:%M:%S',
                '%d/%m/%Y %H:%M:%S',
                '%Y%m%dT%H%M%SZ',
                '%Y%m%d %H%M%S',
                '%Y-%m-%d',
                '%Y/%m/%d',
                '%m/%d/%Y',
            ]
            
            for fmt in formats:
                try:
                    return datetime.datetime.strptime(value, fmt)
                except (ValueError, TypeError):
                    continue
        
        # If we get here and value is not None, try the parent
        if value is not None:
            try:
                return super().to_internal_value(value)
            except:
                # Last resort: try to create from timestamp
                try:
                    if isinstance(value, (int, float)):
                        return datetime.datetime.fromtimestamp(value)
                    elif isinstance(value, str) and value.isdigit():
                        return datetime.datetime.fromtimestamp(int(value))
                except:
                    pass
        
        # If nothing works, return None (or raise validation error)
        return None
    
    def to_representation(self, value):
        # Always return ISO format for consistency
        if value:
            return value.isoformat()
        return None

class VisitSerializer(serializers.ModelSerializer):
    # Use flexible fields
    schedule_start_time = FlexibleDateTimeField(required=False)
    schedule_end_time = FlexibleDateTimeField(required=False)
    actual_start_time = FlexibleDateTimeField(required=False)
    actual_end_time = FlexibleDateTimeField(required=False)
    
    # These will be auto-generated by the model
    visit_other_id = serializers.CharField(read_only=True)
    sequence_id = serializers.CharField(required=False)
    
    # created_by is optional and can be null
    created_by = serializers.PrimaryKeyRelatedField(
        queryset=Employee.objects.all(),
        required=False,
        allow_null=True
    )
    
    class Meta:
        model = Visit
        fields = [
            'id', 'client', 'employee', 'visit_other_id', 'sequence_id',
            'visit_type', 'schedule_start_time', 'schedule_end_time',
            'actual_start_time', 'actual_end_time', 'start_latitude',
            'start_longitude', 'end_latitude', 'end_longitude',
            'location_verified', 'location_distance_miles',
            'payer_id', 'procedure_code', 'visit_time_zone',
            'client_verified_times', 'client_verified_tasks',
            'client_verified_service', 'client_signature_available',
            'client_voice_recording', 'bill_visit', 'hours_to_bill',
            'hours_to_pay', 'tasks_completed', 'tasks_refused',
            'calls', 'visit_changes', 'memo', 'contingency_plan',
            'submitted_to_evv', 'evv_submission_id', 'evv_submission_date',
            'created_at', 'updated_at', 'created_by'
        ]
        read_only_fields = [
            'id', 'created_at', 'updated_at', 'submitted_to_evv',
            'evv_submission_id', 'evv_submission_date', 'visit_other_id'
        ]
    
    def create(self, validated_data):
        # Remove visit_other_id if somehow provided
        validated_data.pop('visit_other_id', None)
        
        # Remove sequence_id if empty
        if 'sequence_id' in validated_data and not validated_data['sequence_id']:
            validated_data.pop('sequence_id')
        
        # If created_by is not provided, set to None
        if 'created_by' not in validated_data:
            validated_data['created_by'] = None
        
        return super().create(validated_data)
    
class UserSerializer(serializers.ModelSerializer):
    class Meta:
        model = User
        fields = ['id', 'email', 'name', 'role', 'email_verified_at']
        read_only_fields = ['id', 'email_verified_at']
    
class UserCreateSerializer(serializers.ModelSerializer):
    """Serializer for creating users from employee data"""
    password = serializers.CharField(write_only=True, required=False)
    employee_id = serializers.CharField(write_only=True, required=False)
    
    class Meta:
        model = User
        fields = ['id', 'email', 'name', 'role', 'password', 'employee_id']
        read_only_fields = ['id']
    
    def create(self, validated_data):
        """Create a user from employee data"""
        employee_id = validated_data.pop('employee_id', None)
        password = validated_data.pop('password', None)
        
        # Generate password if not provided
        if not password:
            import secrets
            password = secrets.token_urlsafe(12)
        
        # Create user
        user = User.objects.create_user(
            email=validated_data['email'],
            name=validated_data['name'],
            password=password,
            role=validated_data.get('role', 'caregiver')
        )
        
        # Link to employee if employee_id provided
        if employee_id:
            try:
                employee = Employee.objects.get(employee_id=employee_id)
                employee.user = user
                employee.save(update_fields=['user'])
            except Employee.DoesNotExist:
                # Employee not found, but user is created anyway
                pass
        
        return user
    
class EmployeeSerializer(serializers.ModelSerializer):
    date_of_birth = FlexibleDateField(required=False)
    hire_date = FlexibleDateField(required=False)
    
    # Add these fields to show user relationship
    user = UserSerializer(read_only=True)
    is_user_account_created = serializers.SerializerMethodField()
    
    class Meta:
        model = Employee
        fields = '__all__'
    
    def get_is_user_account_created(self, obj):
        """Check if a user account exists for this employee"""
        return hasattr(obj, 'user') and obj.user is not None
    
    def create(self, validated_data):
        """Override create to ensure email uniqueness"""
        # Check if email already exists as a user
        email = validated_data.get('email')
        
        # Check if user already exists with this email
        existing_user = User.objects.filter(email=email).first()
        if existing_user:
            # Check if this user is already linked to another employee
            if hasattr(existing_user, 'employee_profile') and existing_user.employee_profile:
                raise serializers.ValidationError({
                    'email': f'User with email {email} is already linked to another employee'
                })
            else:
                # Link existing user to this employee
                employee = super().create(validated_data)
                employee.user = existing_user
                employee.save(update_fields=['user'])
                return employee
        
        # Create the employee first (signal will create user)
        employee = super().create(validated_data)
        
        return employee
    
    def update(self, instance, validated_data):
        """Override update to sync with user account"""
        email = validated_data.get('email')
        
        if email and email != instance.email:
            # Check if new email already exists as a user
            existing_user = User.objects.filter(email=email).first()
            if existing_user and existing_user != instance.user:
                raise serializers.ValidationError({
                    'email': f'Email {email} is already in use by another user'
                })
        
        # Update employee
        employee = super().update(instance, validated_data)
        
        # Sync with user if exists
        if employee.user:
            # Update user email if changed
            if 'email' in validated_data:
                employee.user.email = validated_data['email']
            
            # Update user name if employee name changed
            if 'first_name' in validated_data or 'last_name' in validated_data:
                first_name = validated_data.get('first_name', instance.first_name)
                last_name = validated_data.get('last_name', instance.last_name)
                employee.user.name = f"{first_name} {last_name}"
            
            employee.user.save()
        
        return employee
    
class ClientSerializer(serializers.ModelSerializer):
    date_of_birth = FlexibleDateField(required=False)

    class Meta:
        model = Client
        fields = '__all__'


class EVVXrefSerializer(serializers.Serializer):
    """Serializer for EVV-compliant Xref data"""
    
    def to_representation(self, instance):
        """Convert Xref instance to EVV format"""
        
        # Get validated client Medicaid ID
        client_medicaid = getattr(instance.client, 'medicaid_id', '')
        if not client_medicaid or not re.match(r'^A\d{8}$', client_medicaid):
            raise serializers.ValidationError(f"Invalid Medicaid ID for client {instance.client}")
        
        # Get employee SSN
        employee_ssn = getattr(instance.employee, 'ssn', '')
        if not employee_ssn or not re.match(r'^\d{9}$', employee_ssn):
            raise serializers.ValidationError(f"Invalid SSN for employee {instance.employee}")
        
        # Check procedure code is in allowed list (Section 10.10)
        allowed_codes = ['S5125', 'T2017', 'T1021', 'S5130', 'T1019', 'S5150', 'S5151']
        if instance.procedure_code not in allowed_codes:
            raise serializers.ValidationError(
                f"Procedure code {instance.procedure_code} not allowed for live-in caregiver"
            )
        
        # Build the EVV-compliant payload
        return {
            "ClientIDQualifier": "ClientMedicaidID",
            "ClientIdentifier": client_medicaid,
            "EmployeeQualifier": "EmployeeSSN",
            "EmployeeIdentifier": employee_ssn,
            "XRefStartDate": instance.start_date.isoformat() if instance.start_date else None,
            "XRefEndDate": instance.end_date.isoformat() if instance.end_date else None,
            "PayerID": instance.payer_id,
            "PayerProgram": "AHCCCS",  # REQUIRED: Must be exactly "AHCCCS"
            "ProcedureCode": instance.procedure_code,
            "Modifier1": instance.modifier1,
            "Modifier2": instance.modifier2,
            "Modifier3": instance.modifier3,
            "Modifier4": instance.modifier4,
            "LiveIn": instance.live_in,  # Must be "Yes" or "No" as string
            "Relationship": instance.relationship
        }

# serializers.py - UPDATE XrefSerializer
class XrefSerializer(serializers.ModelSerializer):
    """
    Simplified serializer for ClientEmployeeXref
    Accepts client and employee IDs directly
    """
    client_id = serializers.IntegerField(write_only=True, required=True)
    employee_id = serializers.IntegerField(write_only=True, required=True)
    start_date = FlexibleDateField(required=True)  # CHANGED TO FlexibleDateField
    end_date = FlexibleDateField(required=False, allow_null=True)  # CHANGED TO FlexibleDateField
    
    class Meta:
        model = ClientEmployeeXref
        fields = [
            'id', 'client_id', 'employee_id', 'xref_other_id', 'sequence_id',
            'start_date', 'end_date', 'payer_id', 'payer_program',
            'procedure_code', 'modifier1', 'modifier2', 'modifier3', 'modifier4',
            'live_in', 'relationship', 'submitted_to_evv', 'evv_submission_id',
            'evv_submission_date', 'created_at', 'updated_at'
        ]
        read_only_fields = [
            'id', 'xref_other_id', 'sequence_id', 'created_at', 'updated_at',
            'submitted_to_evv', 'evv_submission_id', 'evv_submission_date'
        ]
    
    def validate(self, data):
        """Validate the xref data"""
        # Check if end_date is after start_date
        if data.get('end_date') and data['end_date'] <= data['start_date']:
            raise serializers.ValidationError({
                'end_date': 'End date must be after start date'
            })
        
        # Validate procedure code is in allowed list
        allowed_codes = ['S5125', 'T2017', 'T1021', 'S5130', 'T1019', 'S5150', 'S5151']
        if data.get('procedure_code') not in allowed_codes:
            raise serializers.ValidationError({
                'procedure_code': f'Procedure code must be one of: {", ".join(allowed_codes)}'
            })
        
        # Validate relationship is in allowed list
        allowed_relationships = [
            'Spouse', 'Adult children/Stepchildren', 'Son-in-law/Daughter-in-law',
            'Grandchildren', 'Siblings/Step siblings', 'Parents/Adoptive Parents/Legal Guardians',
            'Stepparents', 'Grandparents', 'Mother-in-law/Father-in-law',
            'Brother-in-law/Sister-in-law', 'Other'
        ]
        if data.get('relationship') not in allowed_relationships:
            raise serializers.ValidationError({
                'relationship': 'Please select a valid relationship type'
            })
        
        return data
    
    def create(self, validated_data):
        """Create a new xref record"""
        try:
            with transaction.atomic():
                # Extract client_id and employee_id
                client_id = validated_data.pop('client_id')
                employee_id = validated_data.pop('employee_id')
                
                # Get client and employee objects
                client = Client.objects.get(id=client_id)
                employee = Employee.objects.get(id=employee_id)
                
                # Check if relationship already exists
                existing_xref = ClientEmployeeXref.objects.filter(
                    client=client,
                    employee=employee
                ).first()
                
                if existing_xref:
                    # Update existing relationship
                    for field, value in validated_data.items():
                        setattr(existing_xref, field, value)
                    
                    # Increment sequence ID
                    existing_xref.sequence_id += 1
                    existing_xref.save()
                    
                    logger.info(f"Updated existing xref: {existing_xref.xref_other_id}")
                    return existing_xref
                
                # Create new xref
                validated_data['client'] = client
                validated_data['employee'] = employee
                
                # Auto-generate xref_other_id
                if 'xref_other_id' not in validated_data or not validated_data.get('xref_other_id'):
                    timestamp = int(timezone.now().timestamp())
                    validated_data['xref_other_id'] = f"XREF_{client.id}_{employee.id}_{timestamp}"
                
                # Set default sequence ID
                if 'sequence_id' not in validated_data:
                    validated_data['sequence_id'] = 1
                
                # Set default values if not provided
                if 'payer_program' not in validated_data:
                    validated_data['payer_program'] = 'AHCCCS'
                
                if 'live_in' not in validated_data:
                    validated_data['live_in'] = 'No'
                
                xref = ClientEmployeeXref.objects.create(**validated_data)
                logger.info(f"Created new xref: {xref.xref_other_id}")
                
                return xref
                
        except Client.DoesNotExist:
            raise serializers.ValidationError({
                'client_id': 'Client not found'
            })
        except Employee.DoesNotExist:
            raise serializers.ValidationError({
                'employee_id': 'Employee not found'
            })
        except Exception as e:
            logger.exception(f"Error creating xref: {str(e)}")
            raise serializers.ValidationError({
                'error': f'Failed to create xref: {str(e)}'
            })
# Special serializers for EVV transformation
class EVVVisitSerializer(serializers.Serializer):
    """Serializer for transforming Visit objects to EVV format"""
    
    def to_representation(self, instance):
        """Convert Visit instance to EVV-compliant JSON"""
        
        if instance.visit_type == 'scheduled':
            return self._format_scheduled_visit(instance)
        else:  # completed
            return self._format_completed_visit(instance)
    
    def _format_scheduled_visit(self, visit):
        """Format a scheduled visit (no calls)"""
        return {
            "ProviderIdentification": {
                "ProviderQualifier": "MedicaidID",
                "ProviderID": "211108"  # Should be from settings
            },
            "VisitOtherID": visit.visit_other_id,
            "SequenceID": visit.sequence_id,
            "EmployeeQualifier": "EmployeeSSN",
            "EmployeeIdentifier": str(visit.employee.ssn),
            "ClientIDQualifier": "ClientCustomID",
            "ClientID": str(visit.client.medicaid_id),
            "ClientOtherID": str(visit.client.medicaid_id),
            "VisitCancelledIndicator": False,
            "PayerID": visit.payer_id,
            "PayerProgram": "AHCCCS",
            "ProcedureCode": visit.procedure_code,
            "Modifier1": None,
            "Modifier2": None,
            "Modifier3": None,
            "Modifier4": None,
            "VisitTimeZone": visit.visit_time_zone,
            "ScheduleStartTime": visit.schedule_start_time.strftime("%Y-%m-%dT%H:%M:%SZ") if visit.schedule_start_time else None,
            "ScheduleEndTime": visit.schedule_end_time.strftime("%Y-%m-%dT%H:%M:%SZ") if visit.schedule_end_time else None,
            "AdjInDateTime": None,
            "AdjOutDateTime": None,
            "BillVisit": visit.bill_visit,
            "HoursToBill": 0,
            "HoursToPay": 0,
            "Memo": visit.memo or f"Scheduled visit for {visit.client.first_name}",
            "ClientVerifiedTimes": False,
            "ClientVerifiedTasks": False,
            "ClientVerifiedService": False,
            "ClientSignatureAvailable": False,
            "ClientVoiceRecording": False,
            "ContingencyPlan": visit.contingency_plan or None,
            "Reschedule": False,
            "Calls": [],  # No calls for schedules
            "VisitChanges": [],
            "VisitTasks": []
        }
    
    def _format_completed_visit(self, visit):
        """Format a completed visit (with calls)"""
        
        # Format calls
        formatted_calls = []
        for call in visit.calls:
            formatted_calls.append({
                "CallExternalID": call.get('call_external_id', f"CALL{int(datetime.datetime.now().timestamp())}"),
                "CallDateTime": call.get('call_date_time'),
                "CallAssignment": call.get('call_assignment'),
                "GroupCode": None,
                "CallType": call.get('call_type', 'Mobile'),
                "ProcedureCode": call.get('procedure_code', visit.procedure_code),
                "ClientIdentifierOnCall": call.get('client_identifier_on_call', str(visit.client.medicaid_id)),
                "MobileLogin": call.get('mobile_login', ''),
                "CallLatitude": call.get('call_latitude'),
                "CallLongitude": call.get('call_longitude'),
                "Location": call.get('location', ''),
                "VisitLocationType": call.get('visit_location_type', '1'),
                "TelephonyPIN": None,
                "OriginatingPhoneNumber": None,
                "IpAddress": None,
                "WorkerPin": None
            })
        
        # Format tasks
        formatted_tasks = []
        for task_id in visit.tasks_completed:
            formatted_tasks.append({
                "TaskID": task_id,
                "TaskRefused": False
            })
        
        for task_id in visit.tasks_refused:
            formatted_tasks.append({
                "TaskID": task_id,
                "TaskRefused": True
            })
        
        # Format visit changes
        formatted_changes = []
        for change in visit.visit_changes:
            formatted_changes.append({
                "SequenceID": change.get('sequence_id'),
                "ChangeMadeBy": change.get('change_made_by'),
                "ChangeDateTime": change.get('change_date_time'),
                "GroupCode": None,
                "ReasonCode": change.get('reason_code'),
                "ChangeReasonMemo": change.get('change_reason_memo', ''),
                "ResolutionCode": None
            })
        
        return {
            "ProviderIdentification": {
                "ProviderQualifier": "MedicaidID",
                "ProviderID": "211108"  # Should be from settings
            },
            "VisitOtherID": visit.visit_other_id,
            "SequenceID": visit.sequence_id,
            "EmployeeQualifier": "EmployeeSSN",
            "EmployeeIdentifier": str(visit.employee.ssn),
            "ClientIDQualifier": "ClientCustomID",
            "ClientID": str(visit.client.medicaid_id),
            "ClientOtherID": str(visit.client.medicaid_id),
            "VisitCancelledIndicator": False,
            "PayerID": visit.payer_id,
            "PayerProgram": "AHCCCS",
            "ProcedureCode": visit.procedure_code,
            "Modifier1": None,
            "Modifier2": None,
            "Modifier3": None,
            "Modifier4": None,
            "VisitTimeZone": visit.visit_time_zone,
            "ScheduleStartTime": visit.schedule_start_time.strftime("%Y-%m-%dT%H:%M:%SZ") if visit.schedule_start_time else None,
            "ScheduleEndTime": visit.schedule_end_time.strftime("%Y-%m-%dT%H:%M:%SZ") if visit.schedule_end_time else None,
            "AdjInDateTime": visit.actual_start_time.strftime("%Y-%m-%dT%H:%M:%SZ") if visit.actual_start_time else None,
            "AdjOutDateTime": visit.actual_end_time.strftime("%Y-%m-%dT%H:%M:%SZ") if visit.actual_end_time else None,
            "BillVisit": visit.bill_visit,
            "HoursToBill": float(visit.hours_to_bill),
            "HoursToPay": float(visit.hours_to_pay),
            "Memo": visit.memo or f"Completed visit for {visit.client.first_name}",
            "ClientVerifiedTimes": visit.client_verified_times,
            "ClientVerifiedTasks": visit.client_verified_tasks,
            "ClientVerifiedService": visit.client_verified_service,
            "ClientSignatureAvailable": visit.client_signature_available,
            "ClientVoiceRecording": visit.client_voice_recording,
            "ContingencyPlan": visit.contingency_plan or None,
            "Reschedule": False,
            "Calls": formatted_calls,
            "VisitChanges": formatted_changes,
            "VisitTasks": formatted_tasks
        }